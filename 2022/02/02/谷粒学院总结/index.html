<!DOCTYPE html>
<html lang="en">
<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="keyword" content="undefined">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
           谷粒学院总结 - jhu.blog
        
    </title>

    <link rel="canonical" href="https://hujesse83.github.io/2022/02/02/谷粒学院总结/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- // Hux Delete, sad but pending in China -->
    <link href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/
    css">
   


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('undefined')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#project" title="project">project</a>
                            
                        </div>
                        <h1> 谷粒学院总结</h1>
                        <h2 class="subheading">谷粒学院总结</h2>
                        <span class="meta">
                            Posted by  on
                            2022-02-02
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/"></a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <div>
    <h1>
        post JSJSJSJJS
    </h1>
</div>
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">
                <h1><span id="谷粒学院">谷粒学院</span></h1>
<h1><span id="功能简介">功能简介</span></h1>
<p>谷粒学院，是一个 B2C 模式的职业技能教育系统，分为前台用户系统和后台运营平台。</p>
<h1><span id="项目描述">项目描述</span></h1>
<p>1、在线教育系统，分为前台网站系统和后台运营平台，B2C 模式。</p>
<p>使用了微服务技术架构，前后端分离开发。<br>
前台用户系统包括：首页数据显示、课程列表和详情、名师详情、登录与注册、微信扫码登录、课程支付、课程播放.<br>
后台管理系统包括：讲师管理、课程分类管理、课程管理、统计分析、轮播图管理、订单管理、权限管理等功能。</p>
<p>后端的主要技术架构是：SpringBoot + SpringCloud + SpringSecurity + MyBatis-Plus + MySQL +<br>
Maven+EasyExcel.<br>
前端的架构是：Node.js + Vue.js +element-ui+NUXT+ECharts<br>
其他涉及到的中间件包括 Redis、阿里云 OSS、阿里云视频点播, 阿里云短信服务、微信支付与微信扫码登录.<br>
业务中使用了 ECharts 做图表展示，使用 EasyExcel 完成分类批量添加、注册分布式单点登录使用了 JWT。</p>
<p>一句话总结：<br>
<strong><em>前端部分，使用主流的前端框架 Vue，使用 Es6 的开发规范，采用模块化的开发模式。 后端部分，使用目前流行的 SpringBoot+SpringCloud 进行微服务架构，使用 Feign、Gateway、Hystrix，以及阿里巴巴的 Nacos 等组件搭建了项目的基础环境。</em></strong></p>
<h1><span id="业务架构图">业务架构图</span></h1>
<p><strong><em>后台系统功能</em></strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">、登录功能（Spring</span> <span class="string">security框架）</span></span><br><span class="line"><span class="number">2</span><span class="string">、权限管理</span></span><br><span class="line">	<span class="number">1</span><span class="string">、菜单管理：列表，添加、修改、删除</span></span><br><span class="line">	<span class="number">2</span><span class="string">、角色管理：列表、添加、修改、删除、为角色分配菜单</span></span><br><span class="line">	<span class="number">3</span><span class="string">、用户管理：列表、添加、修改、删除、为用户分配角色</span></span><br><span class="line">	<span class="number">4</span><span class="string">、权限管理表和关系：五张表（权限、角色、用户、权限-角色、角色-用户).</span> <span class="string">多对多需要第三张表连接.</span></span><br><span class="line"><span class="number">3</span><span class="string">、讲师管理模块</span></span><br><span class="line">	<span class="string">条件查询分页列表、添加、修改、删除</span></span><br><span class="line"><span class="number">4</span><span class="string">、课程分类模块</span></span><br><span class="line">	<span class="number">1</span><span class="string">、添加课程分类</span></span><br><span class="line">		<span class="string">读取excel里面分类数据、通过eastExcel添加到数据库.</span></span><br><span class="line">	<span class="number">2</span><span class="string">、显示课程分类</span></span><br><span class="line">		<span class="string">使用树形结构显示课程分类.</span></span><br><span class="line"><span class="number">5</span><span class="string">、课程管理模块（核心）</span></span><br><span class="line">	<span class="number">1</span><span class="string">、课程列表功能</span></span><br><span class="line">	<span class="number">2</span><span class="string">、添加课程（课程发布的流程）</span></span><br><span class="line">		<span class="number">1</span><span class="string">)填写课程基本信息</span></span><br><span class="line">		<span class="number">2</span><span class="string">)添加课程大纲（章节和小节）</span></span><br><span class="line">		<span class="number">3</span><span class="string">)课程信息的确认，最后发布-&gt;表中有个字段status-&gt;</span> <span class="string">normal.课程显示的是status为normal.</span></span><br><span class="line">	<span class="string">问题：课程添加过程中，中途把课程停止添加，重新去添加新的课程，如何找到之前没有发布完成课程，继续进行发布呢？*</span> <span class="string">在课程列表中可以查询未发布课程,</span> <span class="string">找到想要继续发布的课程，点击课程右边超链接把课程继续发布完成，</span></span><br><span class="line">	<span class="string">如何判断课程已经发布?</span></span><br><span class="line">	<span class="string">*</span> <span class="string">通过给数据库设置字段status来判断他现在的状态.</span></span><br><span class="line">	<span class="number">3</span><span class="string">、添加小节上传课程视频</span></span><br><span class="line"><span class="number">6</span><span class="string">、统计分析模块</span></span><br><span class="line">	<span class="number">1</span><span class="string">、后台定时任务统计每日登录、注册、课时浏览数进行统计.</span></span><br><span class="line">	<span class="number">2</span><span class="string">、统计数据图表显示（echarts）</span></span><br><span class="line"><span class="number">7</span><span class="string">、轮播图管理</span></span><br><span class="line">	<span class="string">添加与删除</span></span><br><span class="line"><span class="number">8</span><span class="string">、订单管理</span></span><br><span class="line">	<span class="string">查看已支付</span> <span class="string">和未支付的情况.</span></span><br></pre></td></tr></table></figure>
<p><strong><em>前台系统功能</em></strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">、系统首页数据显示</span></span><br><span class="line">	<span class="number">1</span><span class="string">、banner</span> <span class="string">幻灯片功能.</span></span><br><span class="line">	<span class="string">幻灯片什么时候显示-&gt;?</span> <span class="string">根据id排序,</span> <span class="string">找最新的二条显示.</span></span><br><span class="line">	<span class="number">2</span><span class="string">、显示热门课程.</span></span><br><span class="line">	<span class="string">根据播放量降序显示.</span></span><br><span class="line">	<span class="number">3</span><span class="string">、显示名师大咖.</span></span><br><span class="line"><span class="number">2</span><span class="string">、注册功能</span></span><br><span class="line">	<span class="number">1</span><span class="string">、获取手机验证码注册.</span></span><br><span class="line"><span class="number">3</span><span class="string">、登录功能（单点登录sso实现）</span></span><br><span class="line">	<span class="number">1</span><span class="string">、普通登录</span></span><br><span class="line">	<span class="number">2</span><span class="string">、微信扫码登录</span> <span class="string">重要</span></span><br><span class="line">	<span class="string">oauth2:一种解决方案</span></span><br><span class="line">	<span class="string">*</span> <span class="string">sso(单点登录如何实现的)</span></span><br><span class="line">		<span class="string">我使用的是token的方式，用户登录成功后，根据相关的信息生成token，然后返回给cookie，他每次访问的时候</span>		<span class="string">都会从请求头中获取token的值，并解析获取用信息，判断是否已经登录</span></span><br><span class="line"><span class="number">4</span><span class="string">、名师列表</span></span><br><span class="line"><span class="number">5</span><span class="string">、名师详情功能</span></span><br><span class="line"><span class="number">6</span><span class="string">、课程列表</span></span><br><span class="line">	<span class="number">1</span><span class="string">、条件查询分页功能</span></span><br><span class="line"><span class="number">7</span><span class="string">、课程详情页</span></span><br><span class="line">	<span class="number">1</span><span class="string">、课程信息显示（包含课程基本信息、分类、讲师、课程大纲（章节小节））</span></span><br><span class="line">	<span class="number">2</span><span class="string">、判断视频是否购买</span></span><br><span class="line"><span class="number">8</span><span class="string">、课程视频在线播放</span></span><br><span class="line"><span class="number">9</span><span class="string">、课程支付功能</span></span><br><span class="line">	<span class="number">1</span><span class="string">、生成课程订单.</span></span><br><span class="line">	<span class="number">2</span><span class="string">、生成微信支付二维码</span></span><br><span class="line">	<span class="number">3</span><span class="string">、微信最终支付.</span></span><br><span class="line">	<span class="string">*微信支付实现流程</span></span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt="1"></p>
<h1><span id="技术架构图">技术架构图</span></h1>
<p>1、前端技术点</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">前后端分离开发</span></span><br><span class="line"><span class="string">前端前台系统使用Nuxt（vue）,服务端渲染技术，便于seo</span></span><br><span class="line"><span class="string">前端后台系统使用vue-admin-template(基于vue+elementui)</span></span><br><span class="line"><span class="string">前端：</span></span><br><span class="line">	<span class="number">1</span><span class="string">、vue</span></span><br><span class="line">		<span class="string">基本语法</span></span><br><span class="line">		<span class="string">指令：v-bind，v-for，v-if，v-html，绑定事件@click</span></span><br><span class="line">		<span class="string">生命周期：created（页面渲染之前）、mounted（页面挂载之前）</span></span><br><span class="line">	<span class="string">ES6规范</span></span><br><span class="line">	<span class="number">2</span><span class="string">、element-ui</span></span><br><span class="line">	<span class="number">3</span><span class="string">、环境：nodejs,</span> <span class="string">(js允许环境)</span></span><br><span class="line">	<span class="number">4</span><span class="string">、NPM包管理器,</span> <span class="string">类似于maven;</span> <span class="string">npm</span> <span class="string">init</span> <span class="string">、</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">\</span></span><br><span class="line">	<span class="number">5</span><span class="string">、babel</span> <span class="string">转码器、es6-&gt;es5.</span></span><br><span class="line">	<span class="number">6</span><span class="string">、前端模块化.</span> <span class="string">api中定义方法、vue页面引入js文件.</span></span><br><span class="line">	<span class="string">ES6使用</span> <span class="string">export</span> <span class="string">和</span> <span class="string">import</span> <span class="string">来导出、导入模块。</span></span><br><span class="line">	<span class="string">问题：es6的模块化无法在node.js中运行，需要用babel转成es5才能运行.无需手动转，vue框架自动帮我们做了</span></span><br><span class="line">	<span class="number">7</span><span class="string">、webpack</span></span><br><span class="line">	<span class="string">Webpack</span> <span class="string">可以将多种静态资源</span> <span class="string">js、css、less</span> <span class="string">转换成一个静态文件，减少了页面的</span></span><br><span class="line"><span class="string">请求。</span></span><br><span class="line">	<span class="number">8</span><span class="string">、echarts</span> <span class="string">图表工具，使用了折线图.</span></span><br></pre></td></tr></table></figure>
<p>2、后端技术点</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">、微服务架构</span></span><br><span class="line"><span class="number">2</span><span class="string">、springboot</span></span><br><span class="line">	<span class="string">springboot本质就是spring，只是快速构建spring工程脚手架</span></span><br><span class="line">	<span class="string">细节：包扫描：启动类同级包下面,</span> <span class="string">还可以手动设置扫描规则:@ComponentScan("")</span></span><br><span class="line">	<span class="string">配置类：@Configuration</span></span><br><span class="line">	<span class="string">配置文件:properties、yaml、yml.</span> <span class="string">bootstrap配置文件优先级最高</span></span><br><span class="line"><span class="number">3</span><span class="string">、Spring</span> <span class="string">cloud</span></span><br><span class="line">	<span class="string">是很多框架总称，使用这些框架实现微服务框架、基于springboot.</span></span><br><span class="line">	<span class="string">组成框架：1、如下图</span></span><br><span class="line">	<span class="string">项目中使用了阿里巴巴Nacos，代替springcloud一些组件</span></span><br><span class="line">	<span class="string">使用nacos作为配置中心，使用nacos作为配置中心.</span></span><br><span class="line">	<span class="string">Feign：服务调用，一个微服务调用宁外一个微服务，实现远程调用。</span></span><br><span class="line">	<span class="string">熔断器Hystrix.</span></span><br><span class="line">	<span class="string">springcloud</span> <span class="string">之前使用的zuul网关，目前gateway网关</span></span><br><span class="line">	<span class="string">springcloud版本对应</span></span><br><span class="line"><span class="string">*</span> <span class="string">spring</span> <span class="string">security</span></span><br><span class="line">	<span class="string">在项目中整合权限框架实现权限管理功能</span></span><br><span class="line">	<span class="string">spring</span> <span class="string">security框架组成：认证和授权</span></span><br><span class="line">	<span class="string">spring</span> <span class="string">security登录认证过程</span></span><br><span class="line">	<span class="string">spring</span> <span class="string">securoty代码执行过程</span></span><br><span class="line"></span><br><span class="line"><span class="string">*</span> <span class="string">redis</span></span><br><span class="line">	<span class="number">1</span><span class="string">、首页数据进行缓存.</span></span><br><span class="line">	<span class="number">2</span><span class="string">、redis数据类型：字符串、list</span> <span class="string">、set、hash</span> <span class="string">、zset</span></span><br><span class="line">	<span class="number">3</span><span class="string">、不太重要或者不经常改变但经常访问的数据适合做缓存.</span></span><br><span class="line"><span class="string">*</span> <span class="string">nginx</span></span><br><span class="line">	<span class="number">1</span><span class="string">、反向代理服务器</span></span><br><span class="line">	<span class="number">2</span><span class="string">、请求转发、负载均衡、动静分离</span></span><br><span class="line"><span class="string">*</span> <span class="string">Oauth2</span> <span class="string">+</span> <span class="string">JWT</span></span><br><span class="line">	<span class="number">1</span><span class="string">、Othau2针对特点问题解决方案</span></span><br><span class="line">	<span class="number">2</span><span class="string">、jwt包含三部分</span></span><br><span class="line"><span class="string">*</span> <span class="string">httpClient</span></span><br><span class="line">	<span class="number">1</span><span class="string">、发送请求返回响应的工具，不需要浏览器完成请求和访问的过程</span></span><br><span class="line">	<span class="number">2</span><span class="string">、应用场景：wx登录获取扫码人信息、微信支付查询支付信息</span></span><br><span class="line"><span class="string">*</span> <span class="string">cookie</span></span><br><span class="line">	<span class="number">1</span><span class="string">、cookie特点：客户端技术，每次你发送请求都会带着cookie值进行发送.</span> <span class="string">cookie有默认有效时长，关闭浏览器cookie就不存在了.通过setMaxAge可以设置.</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span><span class="string">、mybatis-plus</span></span><br><span class="line">	<span class="string">what：mp就是mybatis的增强.</span></span><br><span class="line">	<span class="string">自动填充</span></span><br><span class="line">	<span class="string">乐观锁</span></span><br><span class="line">	<span class="string">逻辑删除</span></span><br><span class="line">	<span class="string">代码生成器</span></span><br><span class="line"><span class="number">5</span><span class="string">、easyexcel</span></span><br><span class="line">	<span class="string">alibaba操作excel的工具,</span> <span class="string">读写速度高.(对poi进行封装,采用sax方式解析.poi是把数据全部装进内存，现在sax是一行一行解析,不会产生内存溢出的情况)</span></span><br><span class="line"><span class="number">6</span><span class="string">、阿里云oss</span></span><br><span class="line">	<span class="number">1</span><span class="string">、对象存储,</span> <span class="string">上传讲师头像.</span></span><br><span class="line"><span class="number">7</span><span class="string">、阿里云视频点播，视频上传.</span></span><br><span class="line">	<span class="number">1</span><span class="string">、视频上传，删除，播放</span></span><br><span class="line">	<span class="number">2</span><span class="string">、整合阿里云视频播放器进行视频播放</span></span><br><span class="line">		<span class="string">视频地址和凭证播放区别,</span> <span class="string">加密了视频使用视频地址是不可以播放的，只要凭证才能。</span></span><br><span class="line"><span class="string">*</span> <span class="string">阿里云短信服务</span></span><br><span class="line">	<span class="string">注册发送手机验证码.</span></span><br><span class="line"><span class="number">8</span><span class="string">、微信扫码登录</span></span><br><span class="line"><span class="string">*流程</span></span><br><span class="line"><span class="number">9</span><span class="string">、微信支付</span></span><br><span class="line"><span class="string">*流程</span></span><br><span class="line"><span class="number">10</span><span class="string">、maven</span></span><br><span class="line"><span class="number">11</span><span class="string">、git</span></span><br></pre></td></tr></table></figure>
<p><img src="2.png" alt="2"></p>
<h1><span id="遇到的问题">遇到的问题</span></h1>
<p><strong>1、统一返回的 json 时间格式问题</strong><br>
默认情况下 json 时间格式带有时区, 并且是世界标准时间, 和我们的时间差了 8 个小时.<br>
在 application.prperties 里面配置</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.jackson.date-format</span>=yyyy-MM-dd HH:mm:ss</span><br><span class="line"><span class="attr">spring.jackson.time-zone</span>=GMT+<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><strong>2、跨域问题</strong></p>
<p>什么是跨域：浏览器从一个域名的网页去请求另一个域名的资源时, 域名、端口、协议任一不同. 就会产生跨域问题.<br>
解决办法：</p>
<ul>
<li>controller 上加上@CrosOrigin 注解</li>
<li>通过配置类 CorsConfiguration 配置 allowMethod、allowOrigin、allowheader 解决.<br>
<strong>3、路由切换问题</strong><br>
vue-router 导航切换 时，如果两个路由都渲染同个组件，组件会重用,<br>
组件的生命周期钩子（created）不会再被调用, 使得组件的一些数据无法根据 path 的改变得到更新<br>
因此：<br>
1、我们可以在 watch 中监听路由的变化，当路由变化时，重新调用 created 中的内容</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;  <span class="comment">//监听</span></span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123; <span class="comment">//路由变化方式，路由发生变化，方法就会执行</span></span><br><span class="line">        <span class="keyword">this</span>.courseInfo=&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、在 init 方法中我们判断路由的变化，如果是修改路由，则从 api 获取表单数据，<br>
如果是新增路由，则重新初始化表单数据（通过 param 判断）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">init() &#123;</span><br><span class="line"><span class="comment">//判断路径有id值,做修改</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.$route.params &amp;&amp; <span class="keyword">this</span>.$route.params.id) &#123;</span><br><span class="line"><span class="comment">//从路径获取id值</span></span><br><span class="line"><span class="keyword">const</span> id = <span class="keyword">this</span>.$route.params.id</span><br><span class="line"><span class="comment">//调用根据id查询的方法</span></span><br><span class="line"><span class="keyword">this</span>.getInfo(id)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//路径没有id值，做添加</span></span><br><span class="line"><span class="comment">//清空表单</span></span><br><span class="line"><span class="keyword">this</span>.teacher = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><strong>4、oss 模块中有数据库的依赖, 但配置文件没有配置数据源,导致启动报错</strong><br>
spring boot 会默认加载 org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration 这个类，而 DataSourceAutoConfiguration 类使用了@Configuration 注解向 spring 注入了 dataSource bean，又因为项目（oss 模块）中并没有关于 dataSource 相关的配置信息，所以当 spring 创建 dataSource bean 时因缺<br>
少相关的信息就会报错。<br>
解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude = DataSourceAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>5、oss 模块上传图片 413 错误(Request Entity Too large)报错</strong><br>
使用了 nginxweb 服务器，并且上传到文件比较大时, 会爆 413 Request Entity Too large 的错误.<br>
解决办法：修改 nginx 的最大上传限制</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_max_body_size  <span class="number">1024</span>m;  #最大限制为<span class="number">1024</span>M</span><br></pre></td></tr></table></figure>
<p>之后测试再上传一个大一点的图片, 爆：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.multipart</span><span class="selector-class">.MaxUploadSizeExceededException</span></span><br></pre></td></tr></table></figure>
<p>是因为 springboot 自动配置了对上传文件大小的限制, 默认单个文件最大 1Mb,单次请求文件总数大小最大 10Mb<br>
修改为</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">spring</span>.servlet.multipart.<span class="keyword">max</span>-<span class="keyword">file</span>-<span class="keyword">size</span> = <span class="number">20</span>MB</span><br><span class="line"><span class="keyword">spring</span>.servlet.multipart.<span class="keyword">max</span>-request-<span class="keyword">size</span>=<span class="number">20</span>MB</span><br></pre></td></tr></table></figure>
<p><strong>6、properties 文件中 ‘=’ 右边不能加空格，末尾也是.</strong><br>
<strong>7、maven 打包问题</strong><br>
<strong><em>问题一：</em></strong><br>
Maven 加载的时候，把 Java 文件夹里面.java 文件类型文件进行编译，如果有其他类型文件不会加载.<br>
解决办法：</p>
<ul>
<li>将 xml 复制到 target 目录下</li>
<li>配置。
<ul>
<li>mybatis-plus.mapper-locations=classpath:com/atguigu/educenter/mapper/xml/*.xml</li>
<li>pom.xml 中配置将打包时会将 java 目录中的*.xml 文件也进行打包<br>
<strong><em>问题二</em></strong><br>
Maven package 打 jar 包的时候, 默认不会将 resources 下的文件打入 classes 文件夹, 导致启动 jar 包无法加载配置文件.<br>
解决办法：</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;resource&gt;</span><br><span class="line">    &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">    &lt;includes&gt;</span><br><span class="line">        &lt;include&gt;**.*&lt;/include&gt;</span><br><span class="line">        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">        &lt;include&gt;**/*/*.*&lt;/include&gt;</span><br><span class="line">    &lt;/includes&gt;</span><br><span class="line">&lt;/resource&gt;</span><br></pre></td></tr></table></figure>
<p><strong><em>问题三</em></strong><br>
多模块打包问题：多个模块具有依赖, 常规的打包方式不实用了.<br>
解决办法：<br>
parent pom 下加入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executable</span>&gt;</span>true<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includeSystemScope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeSystemScope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>common pom 下加入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其他 pom 文件把<build>标签删掉！<br>
<strong>8、前端问题：es6 模块化运行问题：</strong><br>
问题：import 外部 js 文件问题 报错<br>
解决：Nodejs 使用 Babel 把 Es6 代码转换 Es5 代码执行<br>
<strong>9、Mybatis-plus id 问题</strong><br>
mp 生成 id 值长度为 19 位, js 处理数字类型的时候只能处理到 16 位, 所以将 id 类型改为字符串类型.<br>
413:请求体过大<br>
403:跨域<br>
302:访问一个 Url 时，被重定向到另一个 url 上。常用于页面跳转</build></p>
<h1><span id="微服务">微服务</span></h1>
<h2><span id="什么是微服务">什么是微服务</span></h2>
<p>微服务最早由 Martin Fowler 与 James Lewis 于 2014 年共同提出，微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是 HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。</p>
<h2><span id="为什么需要微服务">为什么需要微服务</span></h2>
<p>在传统的 IT 行业软件大多都是各种独立系统的堆砌，这些系统的问题总结来说就是扩展性差，可靠性不高，维护成本高。到后面引入了 SOA(Service Oriented Architecture)服务化，但是，由于 SOA 早期均使用了总线模式，这种总线模式是与某种技术栈强绑定的，比如：J2EE。这导致很多企业的遗留系统很难对接，切换时间太长，成本太高，新系统稳定性的收敛也需要一些时间。</p>
<h2><span id="微服务与单体架构的区别">微服务与单体架构的区别</span></h2>
<p>（1）单体架构所有的模块全都耦合在一块，代码量大，维护困难。<br>
微服务每个模块就相当于一个单独的项目，代码量明显减少，遇到问题也相对来说比较好解决。<br>
（2）单体架构所有的模块都共用一个数据库，存储方式比较单一。<br>
微服务每个模块都可以使用不同的存储方式（比如有的用 redis，有的用 mysql 等），数据库也是单<br>
个模块对应自己的数据库。<br>
（3）单体架构所有的模块开发所使用的技术一样。<br>
微服务每个模块都可以使用不同的开发技术，开发模式更灵活。</p>
<h2><span id="微服务开发框架">微服务开发框架</span></h2>
<p>目前微服务的开发框架，最常用的有以下四个：<br>
Spring Cloud：<a href="http://projects.spring.io/spring-cloud%EF%BC%88%E7%8E%B0%E5%9C%A8%E9%9D%9E%E5%B8%B8%E6%B5%81%E8%A1%8C%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%89" target="_blank" rel="noopener">http://projects.spring.io/spring-cloud（现在非常流行的微服务架构）</a><br>
Dubbo：http：<a href="//dubbo.io">//dubbo.io</a><br>
Dropwizard：<a href="http://www.dropwizard.io" target="_blank" rel="noopener">http://www.dropwizard.io</a> （关注单个微服务的开发）<br>
Consul、etcd&amp;etc.（微服务的模块）</p>
<h2><span id="什么是-springcloud">什么是 springcloud</span></h2>
<p>Spring Cloud 是一系列框架的集合。它利用 Spring Boot 的开发便利性简化了分布式系统基础设施的开<br>
发，如服务发现、服务注册、配置中心、消息总线、负载均衡、 熔断器、数据监控等，都可以用 Spring<br>
Boot 的开发风格做到一键启动和部署。Spring 并没有重复制造轮子，它只是将目前各家公司开发的比较<br>
成熟、经得起实际考验的服务框架组合起来，通过 SpringBoot 风格进行再封装屏蔽掉了复杂的配置和实<br>
现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包</p>
<h2><span id="springcloud-与-springboot-的区别">springcloud 与 springboot 的区别</span></h2>
<p>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于 Spring Boot 快速开发单个微服务。<br>
Spring Cloud 是一个基于 Spring Boot 实现的开发工具；Spring Boot 专注于快速、方便集成的单个微服务个体，Spring Cloud 关注全局的服务治理框架； Spring Boot 使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud 很大的一部分是基于 Spring Boot 来实现，必须基于 Spring Boot 开发。可以单独使用 Spring Boot 开发项目，但是 Spring Cloud 离不开 Spring Boot。</p>
<h2><span id="spring-cloud-相关基础组件">spring cloud 相关基础组件</span></h2>
<p>服务发现——Netflix Eureka （Nacos）<br>
服务调用——Netflix Feign<br>
熔断器——Netflix Hystrix<br>
服务网关——Spring Cloud GateWay<br>
分布式配置——Spring Cloud Config （Nacos）<br>
消息总线 —— Spring Cloud Bus （Nacos）</p>
<h2><span id="八-springcloud-小版本">八、springcloud 小版本</span></h2>
<p>Spring Cloud 小版本分为:<br>
SNAPSHOT： 快照版本，随时可能修改<br>
M： MileStone，M1 表示第 1 个里程碑版本，一般同时标注 PRE，表示预览版版。<br>
SR： Service Release，SR1 表示第 1 个正式版本，一般同时标注 GA：(GenerallyAvailable),表示稳定版<br>
本。</p>
<h2><span id="项目中使用的微服务组件">项目中使用的微服务组件</span></h2>
<h3><span id="nacos-注册中心">Nacos 注册中心</span></h3>
<p>1、基本概念<br>
Nacos 致力于帮助您发现、配置和管理微服务, 属于阿里巴巴<br>
2、本地启动<br>
nacos/conf 下执行 nacos-mysql.sql 脚本, 在本地生成数据库表.<br>
修改 applicaiton.properties 配置文件, 修改数据库连接用户名、密码等.<br>
启动：bin 目录下<br>
<code>./startup.sh -m standalone</code><br>
3、nacos 功能</p>
<ul>
<li>服务发现和服务健康检测</li>
<li>动态配置服务</li>
</ul>
<h3><span id="feign">Feign</span></h3>
<p>1、基本概念<br>
Feign 是 Netflix 开发的声明式、模板化的 HTTP 客户端， Feign 可以帮助我们更快捷、优雅地调<br>
用 HTTP API。<br>
转化请求 Feign 是一个 http 请求调用的轻量级框架，可以以 Java 接口注解的方式调用 Http 请求，封装了 Http 调用流程。<br>
2、导入依赖</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">spring-cloud-starter-openfeign</span></span><br></pre></td></tr></table></figure>
<p>3、启动类添加注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br></pre></td></tr></table></figure>
<p>4、创建包和接口<br>
@FeignClient 注解用于指定从哪个服务中调用功能 ，名称与被调用的服务名保持一致。<br>
@DeleteMapping 注解用于对被调用的微服务进行地址映射。<br>
@PathVariable 注解一定要指定参数名称，否则出错<br>
@Component 注解防止，在其他位置注入 vodClient 时 idea 报错</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@FeignClient</span>(<span class="string">"service-vod"</span>)</span><br><span class="line"><span class="variable">@Component</span></span><br><span class="line">public interface VodClient &#123;</span><br><span class="line"><span class="variable">@DeleteMapping</span>(value = <span class="string">"/eduvod/vod/video/&#123;videoId&#125;"</span>)</span><br><span class="line">public R removeVideo(<span class="variable">@PathVariable</span>(<span class="string">"videoId"</span>) String videoId);</span><br></pre></td></tr></table></figure>
<h3><span id="hystrix">Hystrix</span></h3>
<p>Spring Cloud 在接口调用上，大致会经过如下几个组件配合：<br>
Feign -----&gt;Hystrix —&gt;Ribbon —&gt;Http Client（apache http components 或者 Okhttp） 具体交互流程上，如下<br>
图所示：<br>
<img src="hystrix.png" alt="hystrix"><br>
（1）接口化请求调用当调用被@FeignClient 注解修饰的接口时，在框架内部，将请求转换成 Feign 的请求实例 feign.Request，交由 Feign 框架处理。<br>
（2）<strong>Feign</strong> ：转化请求 Feign 是一个 http 请求调用的轻量级框架，可以以 Java 接口注解的方式调用 Http 请求，封装了 Http 调用流程。<br>
（3）<strong>Hystrix</strong>：熔断处理机制 Feign 的调用关系，会被 Hystrix 代理拦截，对每一个 Feign 调用请<br>
求，Hystrix 都会将其包装成 HystrixCommand,参与 Hystrix 的流控和熔断规则。如果请求判断需要熔断，则 Hystrix 直接熔断，抛出异常或者使用 FallbackFactory 返回熔断 Fallback 结果；如果通过，则将调用请求传递给 Ribbon 组件。<br>
（4）<strong>Ribbon</strong>：服务地址选择 当请求传递到 Ribbon 之后,Ribbon 会根据自身维护的服务列表，根据服务的服务质量，如平均响应时间，Load 等，结合特定的规则，从列表中挑选合适的服务实例，选择好机器之后，然后将机器实例的信息请求传递给 Http Client 客户端，HttpClient 客户端来执行真正的 Http 接口调用；<br>
（5）<strong>HttpClient</strong> ：Http 客户端，真正执行 Http 调用根据上层 Ribbon 传递过来的请求，已经指定了服务地址，则 HttpClient 开始执行真正的 Http 请求<br>
1、Hystrix 概念<br>
Hystrix 是一个供分布式系统使用，提供延迟和容错功能，保证复杂的分布系统在面临不可避免的失败<br>
时，仍能有其弹性。比如系统中有很多服务，当某些服务不稳定的时候，使用这些服务的用户线程将会阻塞，如果没有隔离机制，系统随时就有可能会挂掉，从而带来很大的风险。SpringCloud 使用 Hystrix 组件提供断路器、资源隔离与自我修复功能。 简称：<strong>兜底</strong><br>
2、引入依赖</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">spring-cloud-starter-netflix-hystrix</span></span><br></pre></td></tr></table></figure>
<p>3、配置文件</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启熔断机制</span></span><br><span class="line"><span class="attr">feign.hystrix.enabled</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置hystrix超时时间，默认1000ms</span></span><br><span class="line"><span class="attr">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="number">6000</span></span><br></pre></td></tr></table></figure>
<p>4、开始兜底</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = <span class="string">"service-vod"</span>, fallback = VodFileDegradeFeignClient<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">指定VodFileDegradeFeignClient这个类兜底</span><br></pre></td></tr></table></figure>
<h3><span id="sprincloud-gateway">sprincloud gateway</span></h3>
<p>API 网关是介于客户端和服务器端之间的中间层，所有的外部请<br>
求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控<br>
可以交由 API 网关来做</p>
<h3><span id="spring-cloud-config">spring cloud config</span></h3>
<p>Spring Cloud Config 为分布式系统的外部配置提供了服务端和客户端的支持方案.server 提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client 通过接口获取数据、并依据此数据初始化自己的应用。<br>
<strong>使用 nacos 替换 config</strong><br>
系统配置的集中管理（编辑、存储、分发）、动态更新不重启、回滚配置（变更管理、<br>
历史版本管理、变更审计）等所有与配置相关的活动</p>
<h2><span id="redis">Redis</span></h2>
<p>1、介绍<br>
Redis 是当前比较热门的 NOSQL 系统之一，它是一个开源的使用 ANSI c 语言编写的 key-value 存储系统（区别于 MySQL 的二维表格的形式存储）。和 Memcache 类似，但很大程度补偿了 Memeache 的不<br>
足。和 Memcache 一样，Redis 数据都是缓存在计算机内存中，不同的是，Memcache 只能将数据缓存到内存中，无法自动定期写入硬盘，这就表示，一断电或重启，内存清空，数据丢失。所以 Memcache 的应用场景适用于缓存无需持久化的数据。而 Redis 不同的是它会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，实现数据的持久化。<br>
2、Redis 特点</p>
<ul>
<li>Redis 读取的速度是 110000 次/s，写的速度是 81000 次/s；</li>
<li>原子 。Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作全并后的原子性执行。</li>
<li>支持多种数据结构：string（字符串）；list（列表）；hash（哈希），set（集合）；zset(有序集合)</li>
<li>持久化，集群部署</li>
<li>支持过期时间，支持事务，消息订阅<br>
3、maven 依赖<br>
spring-boot-starter-data-redis<br>
commons-pool2<br>
4、redis 使用场景</li>
<li>热点数据的缓存
<ul>
<li>对于访问量大单不经常修改的数据适合进行缓存 例如首页数据</li>
</ul>
</li>
<li>限时业务的运用
<ul>
<li>短信验证码</li>
</ul>
</li>
<li>计算器相关问题
<ul>
<li>incrby 命令可以实现原子性的递增. 可用于分布式 id 的生成<br>
5、spingboot 缓存注解</li>
</ul>
</li>
<li>@Cacheable
<ul>
<li>根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。</li>
</ul>
</li>
<li>@CachePut
<ul>
<li>使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。</li>
</ul>
</li>
<li>CacheEvict
<ul>
<li>使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上<br>
6、redis 启动</li>
</ul>
</li>
<li>1、关闭 linux 防火墙</li>
<li>2、找到 redis.conf, 注释掉 #bind 127.0.0.1</li>
</ul>
<h1><span id="每日统计数据">每日统计数据</span></h1>
<p>使用定时任务, 每日凌晨执行.<br>
配合 Echarts 使用.</p>
<h1><span id="权限管理">权限管理</span></h1>
<p>不同角色的用户登录后台管理系统拥有不同的菜单权限与功能权限，权限管理包含三个功能模块：菜单<br>
管理、角色管理和用户管理.<br>
rbac:Role-Based Access Control 基于角色的访问控制. like persona.<br>
RBAC 认为 “授权”实际上是 Who、What、How 三元组之间的关系, 也就是 Who 对 What 进行 How 的操作.<br>
数据库五张表<br>
<img src="table.png" alt="table"></p>
<h2><span id="菜单权限管理">菜单（权限）管理</span></h2>
<p>使用树形结构显示…<br>
给角色分配权限</p>
<h2><span id="角色管理">角色管理</span></h2>
<p>角色的 CRUD.</p>
<h2><span id="用户管理">用户管理</span></h2>
<p>用户 CRUD.<br>
给用户分配角色.</p>
<h1><span id="spring-security">Spring Security</span></h1>
<h2><span id="介绍">介绍</span></h2>
<p>Spring Security 基于 Spring 框架，提供了一套<br>
Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（<strong>Authentication</strong>）和用<br>
户授权（<strong>Authorization</strong>）两个部分。<br>
（1）用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认<br>
证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。<br>
（2）用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是<br>
不同。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会<br>
为不同的用户分配不同的角色，而每个角色则对应一系列的权限。<br>
<strong>Spring Security</strong>其实就是用<strong>filter</strong>，多请求的路径进行过滤。<br>
（1）如果是基于 Session，那么 Spring-security 会对 cookie 里的 sessionid 进行解析，找到服务器存储<br>
的 sesion 信息，然后判断当前用户是否符合请求的要求。<br>
（2）如果是 token，则是解析出 token，然后将当前请求加入到 Spring-security 管理的权限信息中去</p>
<h2><span id="认证与授权实现">认证与授权实现</span></h2>
<p>如果系统的模块众多，每个模块都需要就行授权与认证，所以我们选择基于 token 的形式进行授权与认<br>
证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为 key，权限列<br>
表为 value 的形式存入 redis 缓存中，根据用户名相关信息生成 token 返回，浏览器将 token 记录到 cookie 中，<br>
每次调用 api 接口都默认将 token 携带到 header 请求头中，Spring-security 解析 header 头获取 token 信息，解<br>
析 token 获取当前用户名，根据用户名就可以从 redis 中获取权限列表，这样 Spring-security 就能够判断当前<br>
请求是否有权限访问.<br>
代码实现：<br>
核心配置类继承 WebSecurityConfigurerAdapter, 并加上@EnableWebSecurity 注解.<br>
Spring-security 有专门的实体类 UserDetails, 我们可以继承这个类.<br>
我们需要继承一个 UserDetailSevice 接口并且加入到容器中，实现 loadUserByUsername 方法，里面的逻辑通常是从数据库查找出对应用户名的密码然后构造一个 UserDetail 对象，spring security 会根据返回的这个带有正确用户信息的对象和前台传过来的用户名密码进行比对来判断是否认证通过。</p>
<h1><span id="用户登录">用户登录</span></h1>
<h2><span id="用户登录业务介绍">用户登录业务介绍</span></h2>
<h3><span id="单一服务器模式">单一服务器模式</span></h3>
<p>早期单一服务器, 用户认证。<br>
<img src="login1.png" alt="login1"><br>
缺点：单点性能压力, 无法扩展.</p>
<h3><span id="ssosingle-sign-on模式">SSO(single sign on)模式</span></h3>
<p>分布式：sso 模式<br>
<img src="login2.png" alt="login2"><br>
优点：用户身份信息独立管理，更好的分布式管理<br>
​ 可以自己拓展安全策略<br>
缺点：认证服务器访问压力比较大</p>
<h3><span id="token-模式">Token 模式</span></h3>
<p>业务流程图：<br>
<img src="token.png" alt="token"><br>
优点：token 无状态、session 有状态<br>
基于标准化：你的 API 可以采用标准化的 JSON Web Token（JWT）<br>
缺点：占用带宽, 无法在服务器端销毁.<br>
基于微服务开发，选择 token 的形式相对较多，因此我使用 token 作为用户认证的标准</p>
<h4><span id="使用-jwt-进行跨域身份验证">使用 JWT 进行跨域身份验证</span></h4>
<h5><span id="传统用户身份验证">传统用户身份验证</span></h5>
<p><img src="jwt.png" alt="jwt"></p>
<h3><span id="项目会员登录-注册业务流程">项目会员登录、注册业务流程</span></h3>
<h4><span id="登录">登录</span></h4>
<p>后台获取 mobile、password 二个字段, 校验数据库的加盐字段是否和 password 匹配. -&gt; 返回 jwt token.</p>
<h4><span id="注册">注册</span></h4>
<p>获取到 nickname、mobile、password、code 四个字段. 从 redis 获取发送到验证码, 查询数据库中是否存在相同的手机号码, 如果存在说明这个手机号已经注册过了. --&gt; 添加信息到数据库</p>
<h4><span id="微信登录">微信登录</span></h4>
<p><strong><em>微信登录使用的是 OAuth2 授权机制, 使用的是具体的授权码方式实现.</em></strong><br>
第一步：用户点击网站微信登录图标.<br>
后端带上 AppId 和 AppSecret 和回调域名参数请求微信 OAuth2 授权.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String baseUrl = <span class="string">"https://open.weixin.qq.com/connect/qrconnect"</span> +</span><br><span class="line">        <span class="string">"?appid=%s"</span> +  <span class="comment">// 让微信知道是谁在请求</span></span><br><span class="line">        <span class="string">"&amp;redirect_uri=%s"</span> +   <span class="comment">// 是微信接受或拒绝请求后的跳转地址</span></span><br><span class="line">        <span class="string">"&amp;response_type=code"</span> +  <span class="comment">// response_type 表示要求返回授权码(code)</span></span><br><span class="line">        <span class="string">"&amp;scope=snsapi_login"</span> +  <span class="comment">// 表示要请求的授权范围</span></span><br><span class="line">        <span class="string">"&amp;state=%s"</span> +</span><br><span class="line">        <span class="string">"#wechat_redirect"</span>;</span><br><span class="line">        <span class="comment">//对redirect_url进行URLEncoder编码</span></span><br><span class="line">  String redirectUrl = <span class="string">localhost:</span><span class="number">8160</span><span class="regexp">/api/</span>ucenter<span class="regexp">/wx/</span>callback;</span><br></pre></td></tr></table></figure>
<p>上面 URL 中，<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>appid</code>参数让 微信 知道是谁在请求，<code>redirect_uri</code>参数是 微信 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是登录）。scope 也表示资源分配着额外指定的细分权限. 这里是只能做登录.<br>
第二步: 微信返回二维码供用户扫码<br>
返回到字符串如下</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//open</span>.weixin.qq.com/<span class="keyword">connect</span>/qrconnect?appid=wxed9954c01bb89b47&amp;redirect_uri=http%3A%2F%2Flocalhost%3A8160%2Fapi%2Fucenter%2Fwx%2Fcallback&amp;response_type=code&amp;scope=snsapi_login&amp;<span class="keyword">state</span>=atguigu<span class="comment">#wechat_redirect</span></span><br></pre></td></tr></table></figure>
<p>前端使用 qrxxx 组件将字符串转换为微信二维码.<br>
第三步：会员扫码确认登录 , 也就是授权, <strong>微信带上 code 回调 redirect_uri</strong>, 后端再带上 code 和 appId 和 appSecret 请求微信相关地址. 如下图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String baseAccessTokenUrl = <span class="string">"https://api.weixin.qq.com/sns/oauth2/access_token"</span> +</span><br><span class="line">        <span class="string">"?appid=%s"</span> +</span><br><span class="line">        <span class="string">"&amp;secret=%s"</span> +</span><br><span class="line">        <span class="string">"&amp;code=%s"</span> +</span><br><span class="line">        <span class="string">"&amp;grant_type=authorization_code"</span>;  <span class="comment">// 表示采用的方式是授权码</span></span><br></pre></td></tr></table></figure>
<p>使用 httpClient 调用地址, 返回 accessToken.<br>
第四步: 获取 accessToken 中的 appid（每个微信唯一标识）, feign 调用接口, 通过 appid 查询 ucenter_member 这张表是否有存在此 appid.</p>
<ul>
<li>该用户第一次登录：拿着 accessToken 和 appid 请求微信相关地址, 得到该用户的名称, 头像等参数. 并将其加入到数据库中. 并生成 jwt token, 重定向到前端页面.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"redirect:http://localhost:3000?token="</span>+jwtToken;</span><br></pre></td></tr></table></figure>
<ul>
<li>改用户数据库里已经存在, 直接返回 token + 重定向.</li>
</ul>
<h3><span id="项目管理员登录-注册业务流程">项目管理员登录、注册业务流程</span></h3>
<p><a href="https://blog.csdn.net/weixin_44588495/article/details/105907312" target="_blank" rel="noopener">执行流程</a><br>
使用 spring-security 做用户的认证与授权.<br>
认证流程：<br>
<img src="auth1.png" alt="auth1"><br>
我们自己写了个类继承 PasswordEncoder, 重写 encode 和 matches 方法. 使用的是 md5 加密。<br>
授权流程：<br>
<img src="auth2.png" alt="auth2"><br>
用户登出流程：<br>
通过 request 中的 header 的 token, 获取到 token 到 body 到 username, 清楚掉 redis 中 username 的 key.<br>
自定义生成 token:TokenManager 类. token 生成，token 解析, token 过期时间.</p>
<h1><span id="微信支付">微信支付</span></h1>
<p>课程分为免费课程和付费课程，如果是免费课程可以直接观看，如果是付费观看的课程，用户需下<br>
单支付后才可以观看<br>
1、发起生成订单的请求, 我们拿到 courseId 和 HttpServletRequest 二个参数, request 的 header 里面携带有 token, 我们使用 JWt 工具类解析出用户 id（我们使用 jwt 生成 token 时往 token 的 body 里面存放了 id 字段, 所有我们可以解析).根据 courseId 和 userId 远程调用获取信息，存到 order 表里面，使用工具类生成订单 id, 返回订单 id.<br>
2、前端跳转到订单去支付页面, 通过返回的订单 id 调用 api, 回显订单信息, 比如课程名称，支付金额 etc.<br>
3、点击去支付, 后台生成微信支付二维码接口,需要商户 appId, partnerkey,notifyurl 准备条件。微信固定的 api. 前端 qriously 组件解析二维码接口里面的 code_url, 生成图片.<br>
4、扫码支付：每隔 5 秒，通过订单 id 查询支付状态, 如果 status=已支付,后台会将 order 表的状态改为 1（已经支付），同时还会在 pay_log 表中新增一条记录。前台清除前端定时器,跳转到课程页面。</p>
<h1><span id="面试题">面试题</span></h1>
<h2><span id="http-协议是有状态还是无状态的">HTTP 协议是有状态还是无状态的</span></h2>
<h3><span id="定义">定义</span></h3>
<p>Http 无状态协议，是指协议对于交互性场景没有记忆能力.</p>
<h3><span id="举个例子">举个例子</span></h3>
<p>在点击一个纯的 html 网页，请求获取服务器的 html 文件资源时，每次 http 请求都会返回同样的信息，因为这个是没有交互的，每一次的请求都是相互独立的。第一个请求和第二个请求也没有先后顺序，返回处理哪个，结果都是同样的资源页面，因为这种场景是无交互的，无论是什么人请求这个地址，服务器都是返回那个相同的响应。</p>
<h3><span id="具体场景">具体场景</span></h3>
<p>如在购物网站上买一个书包：</p>
<ul>
<li>输入用户名登录</li>
<li>选择一款你喜欢的书包加入到购物车中 /cart 用户信息，产品信息</li>
<li>购买支付 /pay 用户信息，商品信息，金额信息<br>
所谓的登录只是验证你是否是一个合法用户，若是合法则跳转到信息的页面，不合法则告知用户名密码错误。但是我们在第一步给服务器发完/login 接口后，服务器就忘记了。。。忘记了你这个人，到底有没有经过认证。所以在添加商品时/cart 你还是需要将你的账号密码和商品信息一起提交给 addCart 接口，再让服务器做验证。</li>
</ul>
<h3><span id="总结">总结</span></h3>
<p>上面的无状态是指的，无登录状态，即服务器不知道某个用户是否已登录过了。因为愚蠢的服务器不知道客户端是否已登录过了,所以每次都要在交互场景(会话)中请求中带上上一次的请求信息，如账号、密码。明明只需要在/login 接口中，才需要对比数据库中的账号密码和客户端传的是否一致来确定合法性。这下在添加购物车中也需要再一次的进行同样的重复且没有必要的操作，即降低了响应速度，又对用户不友好（因为每次都需要填账号，密码）</p>
<h2><span id="cookie-session-token">cookie、session、token</span></h2>
<p>对于 http 无状态的解决方案：<br>
两种用于保持 HTTP 状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session.<br>
<img src="auth2.png" alt="cookie"></p>
<h4><span id="cookie">Cookie</span></h4>
<p>Cookie 是客户端的存储空间，由浏览器来维持。具体来说 <strong>cookie 机制采用的是在客户端保持状态的方案</strong>。<br>
<strong>实现过程：</strong><br>
cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。cookie 由服务器生成，发送给浏览器，浏览器把 cookie 以 kv 形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该 cookie 发送给服务器。由于 cookie 是存在客户端上的，所以浏览器加入了一些限制确保 cookie 不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的 cookie 数量是有限的<br>
Cookie 在客户端是由浏览器来管理的。浏览器能够保证 Google 只会操作 Google 的 Cookie 而不会操作 Baidu 的 Cookie，从而保证用户的隐私安全<br>
cookie 保存登录信息多种方案</p>
<ul>
<li>方案一：最直接的是把用户名与密码都保持到 Cookie 中，下次访问时检查 Cookie 中的用户名与密码，与数据库比较。这是一种比较危险的选择，一般不把密码等重要信息保存到 Cookie 中。</li>
<li>方案二：是把密码加密后保存到 Cookie 中，下次访问时解密并与数据库比较。这种方案略微安全一些。如果不希望保存密码，还可以把登录的时间戳保存到 Cookie 与数据库中，到时只验证用户名与登录时间戳就可以了。</li>
<li>方案三：只在登录时查询一次数据库，以后访问验证登录信息时不再查询数据库。实现方式是把账号按照一定的规则加密后，连同账号一块保存到 Cookie 中。下次访问时只需要判断账号的加密规则是否正确即可</li>
</ul>
<h4><span id="session">Session</span></h4>
<ul>
<li>Session，中文经常翻译为会话，其本来的含义是指有始有终的一系列动作/消息，比如打电话是从拿起电话拨号到挂断电话这中间的一系列过程可以称之为一个 Session。然而当 Session 一词与网络协议相关联时，它又往往隐含了“面向连接”或“保持状态”这样两个含义。</li>
<li>Session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。</li>
<li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 Session。客户端浏览器再次访问时，只需要从该 Session 中查找该客户的状态就可以了。</li>
<li>虽然 Session 保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为 Session 需要使用 Cookie 作为识别标志。HTTP 协议是无状态的，Session 不能依据 HTTP 连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为 JSESSIONID 的 Cookie，它的值为该 Session 的 id（即放在 HTTP 响应报文头部信息里的 Set-Cookie）。Session 依据该 Cookie 来识别是否为同一用户。</li>
<li>可是 session 有一个缺陷：如果 web 服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候 session 会丢失。</li>
</ul>
<h3><span id="cookie-与-session-的区别">cookie 与 session 的区别</span></h3>
<ul>
<li>cookie 是一个实际存在的、具体的东西，http 协议中定义在 header 中的字段。</li>
<li>Session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。</li>
<li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是 Session。客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态就可以了。</li>
<li>如果说 Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</li>
<li>Cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗，考虑到安全应当使用 Session ；</li>
<li><strong>session 传输数据少，数据结构灵活</strong>：相较于 cookie 来说，session 存储在服务端，客户端仅保留换取 session 的用户凭证。因此传输数据量小，速度快。</li>
<li><strong>session 更安全</strong>：检验、生成、验证都是在服务端按照指定规则完成，而 cookie 可能被客户端通过 js 代码篡改。</li>
<li><strong>session 的不足</strong>：服务器是有状态的。多台后端服务器无法共享 session。<strong>解决方法</strong>是，专门准备一台 session 服务器，关于 session 的所有操作都交给它来调用。而服务器之间的调用，可以走内网 ip，走 RPC 调用（不走 http）。</li>
</ul>
<h3><span id="token">Token</span></h3>
<p>Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。</p>
<ul>
<li>token 是无状态的，支持移动设备，跨程序调用，安全<br>
基于 Token 的身份验证的过程如下</li>
</ul>
<ol>
<li>用户通过用户名和密码发送请求。</li>
<li>程序验证。</li>
<li>程序返回一个签名的 token 给客户端。</li>
<li>客户端储存 token,并且每次用于每次发送请求。</li>
<li>服务端验证 token 并返回数据。</li>
</ol>
<h3><span id="jwt-令牌">JWT 令牌</span></h3>
<p>JWT 是 token 的一种实现。<br>
JWT 的组成：<br>
<img src="jwtRole.png" alt="jwtRole"><br>
该对象为一个很长的字符串，字符之间通过&quot;.&quot;分隔符分为三个子串。<br>
每一个子串表示了一个功能块，总共有以下三个部分：JWT 头、有效载荷和签名<br>
<strong>JWT 头</strong><br>
JWT 头部分是一个描述 JWT 元数据的 JSON 对象，通常如下所示。在上面的代码中，alg 属性表示签名使用的算法，默认为 HMAC SHA256（写为 HS256）；typ 属性表示令</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line"><span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>牌的类型，JWT 令牌统一写为 JWT。最后，使用 Base64 URL 算法将上述 JSON 对象转换为字符串保存。<br>
<strong>有效载荷</strong><br>
有效载荷部分，是 JWT 的主体内容部分，也是一个 JSON 对象，包含需要传递的数据。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"Helen"</span>,</span><br><span class="line"><span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，默认情况下 JWT 是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密<br>
信息，以防止信息泄露。<br>
JSON 对象也使用 Base64 URL 算法转换为字符串保存<br>
<strong>签名哈希</strong><br>
签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。<br>
首先，需要指定一个密码（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法（默认情况下为 HMAC SHA256）根据以下公式生成签名。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(<span class="name">base64UrlEncode</span>(<span class="name">header</span>) + <span class="string">"."</span> + base64UrlEncode(<span class="name">claims</span>), secret)</span><br></pre></td></tr></table></figure>
<p>在计算出签名哈希后，JWT 头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用&quot;.&quot;分隔，就构成整个 JWT 对象。<br>
<strong>JWT 的用法</strong><br>
客户端接收服务器返回的 JWT，将其存储在 Cookie 或 localStorage 中。<br>
此后，客户端将在与服务器交互中都会带 JWT。如果将它存储在 Cookie 中，就可以自动发送，但是不会<br>
跨域，因此一般是将它放入 HTTP 请求的 Header Authorization 字段中。当跨域时，也可以将 JWT 被放置<br>
于 POST 请求的数据主体中。<br>
<strong>JWT 问题与趋势</strong></p>
<ul>
<li>JWT 不仅可用于认证，还可用于信息交换。善用 JWT 有助于减少服务器请求数据库的次数。</li>
<li>生产的 token 可以包含基本信息，比如 id、用户昵称、头像等信息，避免再次查库</li>
<li>存储在客户端，不占用服务端的内存资源</li>
<li>JWT 默认不加密，但可以加密。生成原始令牌后，可以再次对其进行加密。</li>
<li>当 JWT 未加密时，一些私密数据无法通过 JWT 传输。</li>
<li>JWT 的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就</li>
<li>是说，一旦 JWT 签发，在有效期内将会一直有效。</li>
<li>JWT 本身包含认证信息，token 是经过 base64 编码，所以可以解码，因此 token 加密前的对象不应该</li>
<li>包含敏感信息，一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT 的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。</li>
<li>为了减少盗用和窃取，JWT 不建议使用 HTTP 协议来传输代码，而是使用加密的 HTTPS 协议进行传<br>
输。</li>
</ul>
<h3><span id="oauth2">OAuth2</span></h3>
<p>1）介绍：OAuth2 是目前最流行的授权机制，用来授权第三方应用，获取用户数据<br>
2）快递员问题：我住在一个小区，小区有门禁系统，进入的时候需要输入密码，我经常网购，每天都有快递员来送货，我必须找到一个办法，让快递员通过门禁系统.<br>
如果我告诉他密码，他就拥有了我同样的权限，好像不太合适。于是</p>
<ul>
<li>1、门禁系统下面增加一个按钮，叫做<strong>获取授权</strong>, 快递员需要按这个按钮，去申请授权.</li>
<li>2、按下按钮, 我手机上会跳出谈话框-&gt; 快递员 xx 正在申请授权.</li>
<li>3、我点击确定, 门禁得到允许, 向快递员显示一个进入小区的令牌(access token). 在有效时间内有效.</li>
<li>4、快递员向门禁系统输入令牌, 进入小区.<br>
有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。<br>
3）互联网场景<br>
首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的&quot;门禁系统&quot;。<br>
其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。<br>
最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。<br>
<strong>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong><br>
4）令牌与密码区别<br>
（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。<br>
（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。<br>
（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。<br>
<strong><em>OAuth 2.0 是一种授权机制，主要用来颁发令牌（token）</em></strong><br>
OAuth2 如何解决分布式访问的？<br>
1、登录成功之后，按照一定规则生成字符串，字符串包含用户信息<br>
2、把字符串通过路径传递、或者 cookie<br>
3、后面再发请求的时候，每次都带着字符串进行发送，获取字符串，从字符串里面获取用户信息登录。<br>
到这里是不是和 token 很相似. 对的. jwt 是 OAuth2 的一种具体的实现。<br>
OAuth2 主要解决二个问题：</li>
<li>开放间系统授权</li>
<li>分布式访问问题</li>
</ul>
<h3><span id="oauth2-的四种方式">OAuth2 的四种方式</span></h3>
<ul>
<li>授权码（authorization-code）</li>
<li>隐藏式（implicit）</li>
<li>密码式（password）</li>
<li>客户端凭证（client credentials）<br>
以上四种方式, 第三方应用申请令牌，都必须先到系统备案, 说明自己的身份. 然后会拿到二个识别码<br>
<strong>客户端 ID(client ID) 和 客户端密钥(client secret)</strong></li>
</ul>
<h4><span id="授权码">授权码</span></h4>
<p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</strong><br>
第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。<br>
<a href="https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank" rel="noopener">OAuth 2.0 的四种方式</a></p>
<h2><span id="可能追问的问题">可能追问的问题</span></h2>
<p><strong><em>你项目中登录时怎么实现的？</em></strong><br>
<img src="3.png" alt="3"><br>
<strong>你使用什么方式生成 token 的*</strong><br>
使用 Jwt 生成 token 字符串<br>
<strong><em>Jwt 有几部分组成，分别为什么？</em></strong><br>
三部分组成，分别为：jwt 头、有效载荷（用户信息）、签名哈希（防伪标志）<br>
<strong><em>你登录功能的实现流程是什么？</em></strong><br>
调用登录的接口，会返回一个 token 字符串，把 token 字符串放到 cookie 中，创建前端拦截器进行判断，如果 cookie 里包含 token 字符串，把 token 放到 header 中。调用接口会从 header 中取值到 token，根据 token 值获取到用户信息，然后在页面中进行显示.<br>
<strong><em>你是如何获取扫码人微信信息的？</em></strong><br>
扫码后，微信会返回两个值 code 和 state；然后拿着这个 code 去请求微信的固定地址，获得两个值 access*token 访问凭证和 openid 每个微信的唯一表示；然后拿着这两个再去请求微信的一个固定地址获取到扫码人的信息<br>
<strong>系统中都有那些角色？数据库是怎么设计的？<strong>前台：会员（学员）<br>
后台：系统管理员、运营人员<br>
后台分库，每个微服务一个独立的数据库，使用了分布式 id 生成器<br>
<strong>视频点播是怎么实现的（流媒体你们是怎么实现的）</strong><br>
我们直接接入了阿里云的云视频点播。云平台上的功能包括视频上传、转码、加密、智能审核、监控统<br>
计等。<br>
还包括视频播放功能，阿里云还提供了一个视频播放器。<br>
***微信支付的流程_</strong><br>
如果课程是收费课程，点击立即购买，生成课程订单；点击订单页面中的去支付，生成微信支付二维码；使用微信区扫秒二维码实现支付；支付之后，每个 3 秒查询支付状态（是否支付成功），如果没有支付成功就等待，如果支付成功之后，修改订单状态，向支付表中添加记录<br>
<strong>分布式系统的 CAP 原理**<br>
<strong>CAP 定理：</strong><br>
指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分<br>
区容错性），三者不可同时获得。<br>
一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（所有节点在同一时间的<br>
数据完全一致，越多节点，数据同步越耗时）<br>
可用性（A）：负载过大后，集群整体是否还能响应客户端的读写请求。（服务一直可用，而且是正常响<br>
应时间）<br>
分区容错性（P）：分区容错性，就是高可用性，一个节点崩了，并不影响其它的节点（100 个节点，挂<br>
了几个，不影响服务，越多机器越好）<br>
<strong>CA 满足的情况下，P 不能满足的原因：</strong><br>
数据同步©需要时间，也要正常的时间内响应(A)，那么机器数量就要少，所以 P 就不满足</strong>CP 满足的情况下，A 不能满足的原因：</strong><br>
数据同步©需要时间, 机器数量也多§，但是同步数据需要时间，所以不能再正常时间内响应，所以 A 就<br>
不满足<br>
<strong>AP 满足的情况下，C 不能满足的原因：</strong><br>
机器数量也多§，正常的时间内响应(A)，那么数据就不能及时同步到其他节点，所以 C 不满足<br>
<strong>结论：</strong><br>
分布式系统中 P,肯定要满足，所以我们只能在一致性和可用性之间进行权衡<br>
如果要求一致性，则选择 zookeeper，如金融行业<br>
如果要求可用性，则 Eureka，如教育、电商系统<br>
没有最好的选择，最好的选择是根据业务场景来进行架构设计<br>
****前端渲染和后端渲染有什么区别<br>
前端渲染是返回 json 给前端，通过 javascript 将数据绑定到页面上<br>
后端渲染是在服务器端将页面生成直接发送给服务器，有利于 SEO 的优化<br>
<strong>snowflake 算法：</strong></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用<span class="number">41</span>bit作为毫秒数，<span class="number">10</span>bit作为机器的ID（<span class="number">5</span>个bit是数据中心，<span class="number">5</span>个bit的机器ID），<span class="number">12</span>bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 <span class="number">4096</span> 个 ID），最后还有一个符号位，永远是<span class="number">0</span>。<span class="number">64</span>bit <span class="number">8</span> byte.</span><br><span class="line">基于新浪、具有自增点策略.</span><br></pre></td></tr></table></figure>
<p>id 字段使用主键策略：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html" target="_blank" rel="noopener">分布式系统唯一 ID 生成方案汇总</a><br>
<strong>EasyExcel</strong><br>
Java 领域解析、生成 Excel 比较有名的框架有 Apache poi、jxl 等。但他们都存在一个严重的问题就是<br>
非常的耗内存。如果你的系统并发量不大的话可能还行，但是一旦并发上来后一定会 OOM 或<br>
者 JVM 频繁的 full gc。<br>
EasyExcel 是阿里巴巴开源的一个 excel 处理框架，以使用简单、节省内存著称。EasyExcel 能大大减<br>
少占用内存的主要原因是在解析 Excel 时没有将文件数据一次性全部加载到内存中，而是从磁盘上一<br>
行行读取数据，逐个解析。<br>
EasyExcel 采用一行一行的解析模式，并将一行的解析结果以观察者的模式通知处理<br>
（AnalysisEventListener）。<br>
<strong>IDEA 自动生成序列号 iD</strong></p>
<blockquote>
<p>Perference-&gt;Editor-&gt;Inspections-&gt;Serialization issues-&gt;Serializable class without 'serialVersionUUID’<br>
<strong>阿里数据库必有三字段</strong><br>
Gmt: 格林威治时间</p>
</blockquote>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> , gmt_create, gtm_modified.</span><br></pre></td></tr></table></figure>
<p>text 类型 , 要提出来单独一张表<br>
禁止使用物理外键.<br>
<strong><packaging>pom</packaging></strong><br>
使用 maven 分模块管理，都会有一个父级项目，pom 文件一个重要的属性就是 packaging（打包类型），一般来说所有的父级项目的 packaging 都为 pom，packaging 默认类型 jar 类型，如果不做配置，maven 会将该项目打成 jar 包。<br>
<strong>@RequestBody 与 @ResponseBody 和 @RequestParam 区别</strong></p>
<ul>
<li>@Responsebody 注解表示该方法的返回的结果直接写入 HTTP 响应正文中，一般在异步获取数据时使用；</li>
<li>在使用@RequestMapping 后，返回值通常解析为跳转路径，加上@Responsebody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP 响应正文中。例如，异步获取 json 数据，加上@Responsebody 注解后，就会直接返回 json 数据。</li>
<li>@RequestBody 注解则是将 HTTP 求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。</li>
<li><strong>@RequestParam 用来处理 <code>Content-Type</code> 为 <code>application/x-www-form-urlencoded</code> 编码的内容，<code>Content-Type</code>默认为该属性**</strong>。@RequestParam 也可用于其它类型的请求，例如：POST、DELETE 等请求**。<br>
ps: @RequestBody 不能被 get 使用.<br>
<strong><em>reference doc: <a href="https://blog.csdn.net/weixin_38004638/article/details/99655322" target="_blank" rel="noopener">POST、GET、@RequestBody 和@RequestParam 区别</a></em></strong><br>
<strong>@PathVariable</strong><br>
<code>@PathVariable</code>注解，其用来获取请求路径（<code>url</code>）中的动态参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"person/profile/&#123;id&#125;/&#123;name&#125;/&#123;status&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">porfile</span><span class="params">(@PathVariable <span class="keyword">int</span> id, @PathVariable String name, @PathVariable <span class="keyword">boolean</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(id, name, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>项目中使用的异常处理</strong><br>
@RestControllerAdvice + @ExceptionHandler(GuliException.class) 处理特定的异常.<br>
通过日志打印到指定文件中.<br>
<strong>Mybatis-plus 只查询指定列</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrapper.select(<span class="string">"video_source_id"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>Stream 流</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; videoIdList = eduVideoList.stream().map(EduVideo::getVideoSourceId).filter(Objects::nonNull).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p><strong>SEO: search engine optimization 搜索引擎优化</strong><br>
<strong>cms: campaign management system 活动管理系统.</strong><br>
<strong>redis 启动</strong><br>
redis-server /usr/local/etc/redis.conf<br>
redis-cli -h 127.0.0.1 -p 6379<br>
<strong>RBAC</strong><br>
rbac:Role-Based Access Control 基于角色的访问控制. like persona.<br>
RBAC 认为 “授权”实际上是 Who、What、How 三元组之间的关系, 也就是 Who 对 What 进行 How 的操作.</p>
<h1><span id="extention-阿里云-oss">Extention 阿里云 OSS</span></h1>
<h2><span id="准备环境">准备环境</span></h2>
<p>1、申请阿里云账号<br>
2、实名认证<br>
3、开通“对象存储 OSS 服务”<br>
4、进入管理控制台</p>
<h2><span id="开始操作">开始操作</span></h2>
<p>1、创建 Bucket<br>
2、引入公共 maven 的 sdk --&gt;</p>
<blockquote>
<p>aliyun-sdk-oss<br>
aliyun-sdk-core<br>
3、配置文件<br>
endpoint、bucketName、accessKeyId、accessKeySecret<br>
我们使用<code>MultipartFile</code> 接受文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">uploadFileAvatar</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">    String endpoint = ConstantPropertiesUtils.END_POINT;</span><br><span class="line">    String accessKeyId = ConstantPropertiesUtils.KEY_ID;</span><br><span class="line">    String accessKeySecret = ConstantPropertiesUtils.KEY_SECRET;</span><br><span class="line">    String bucketName = ConstantPropertiesUtils.BUCKET_NAME;</span><br><span class="line">    <span class="comment">// 获取文件名。 如果文件名一致会被覆盖</span></span><br><span class="line">    String uuid =  UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>,<span class="string">""</span>);</span><br><span class="line">    String objectName = file.getOriginalFilename();</span><br><span class="line">    objectName = uuid+objectName;</span><br><span class="line">    <span class="comment">// joda time 得到简易日期格式</span></span><br><span class="line">    String dataPath = <span class="keyword">new</span> DateTime().toString(<span class="string">"yyyy/MM"</span>);</span><br><span class="line">    objectName = dataPath +<span class="string">"/"</span>+ objectName;</span><br><span class="line"></span><br><span class="line">    OSS ossClient;</span><br><span class="line">    <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">    ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line">    <span class="keyword">try</span> (InputStream inputStream = file.getInputStream()) &#123;</span><br><span class="line">        ossClient.putObject(bucketName, objectName, inputStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    String url = <span class="string">"https://"</span> + bucketName + <span class="string">"."</span>+endpoint+<span class="string">"/"</span>+objectName;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="extention-阿里云-vod">Extention 阿里云 vod</span></h1>
<p>视频点播（ApsaraVideo for VoD）是集音视频采集、编辑、上传、自动化转码处理、媒体资源管理、分<br>
发加速于一体的一站式音视频点播解决方案。<br>
<img src="vod.png" alt="vod"></p>
<ul>
<li>用户获取上传授权</li>
<li>vod 下发 上传地址和凭证以及 VideoId</li>
<li>用户上传视频保存地址 ID(VideoId)</li>
<li>用户服务端获取播放凭证</li>
<li>Vod 下发带时效的播放凭证</li>
<li>用户服务端将播放凭证下发给客户端完成视频播放<br>
maven
<blockquote>
<p>Aliyun-java-sdk-vod<br>
Aliyun-java-sdk-core<br>
plus：aliyun-java-vod-upload-1.4.11 并未开源<br>
所以我们使用 maven 命令在本地仓库安装 jar 包. 进入到官方 demo-lib 目录下</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file</span><br><span class="line">-DgroupId=com.aliyun</span><br><span class="line">-DartifactId=aliyun-sdk-vod-upload</span><br><span class="line">-Dversion=1.4.11</span><br><span class="line">-Dpackaging=jar</span><br><span class="line">-Dfile=aliyun-java-vod-upload-1.4.11.jar</span><br></pre></td></tr></table></figure>
<h1><span id="extention-阿里云短信服务">Extention 阿里云短信服务</span></h1>
<p>SMS：short message service 短信服务<br>
调用官方 api.<br>
生成短信验证码, 将手机号与短信验证码作为 K-V 存到 Redis. 设置过期时间为 5mins.</p>

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    
                        <li class="next">
                            <a href="/2021/12/26/Java-Annotations/" data-toggle="tooltip" data-placement="top" title="Java Annotations">Next Post &rarr;</a>
                        </li>
                    
                </ul>
                <!-- disqus comment start -->
                
                    <div class="comment">
                        <div id="disqus_thread" class="disqus-thread"></div>
                    </div>
                
                <!-- disqus comment end -->
            </div>
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">谷粒学院</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">功能简介</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">项目描述</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">业务架构图</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">技术架构图</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">遇到的问题</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">微服务</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.1.</span> <span class="toc-nav-text">什么是微服务</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.2.</span> <span class="toc-nav-text">为什么需要微服务</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.3.</span> <span class="toc-nav-text">微服务与单体架构的区别</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.4.</span> <span class="toc-nav-text">微服务开发框架</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.5.</span> <span class="toc-nav-text">什么是 springcloud</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.6.</span> <span class="toc-nav-text">springcloud 与 springboot 的区别</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.7.</span> <span class="toc-nav-text">spring cloud 相关基础组件</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.8.</span> <span class="toc-nav-text">八、springcloud 小版本</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.9.</span> <span class="toc-nav-text">项目中使用的微服务组件</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.9.1.</span> <span class="toc-nav-text">Nacos 注册中心</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.9.2.</span> <span class="toc-nav-text">Feign</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.9.3.</span> <span class="toc-nav-text">Hystrix</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.9.4.</span> <span class="toc-nav-text">sprincloud gateway</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.9.5.</span> <span class="toc-nav-text">spring cloud config</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.10.</span> <span class="toc-nav-text">Redis</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">每日统计数据</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">权限管理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">9.1.</span> <span class="toc-nav-text">菜单（权限）管理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">9.2.</span> <span class="toc-nav-text">角色管理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">9.3.</span> <span class="toc-nav-text">用户管理</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">Spring Security</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">10.1.</span> <span class="toc-nav-text">介绍</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">10.2.</span> <span class="toc-nav-text">认证与授权实现</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">11.</span> <span class="toc-nav-text">用户登录</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">11.1.</span> <span class="toc-nav-text">用户登录业务介绍</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">11.1.1.</span> <span class="toc-nav-text">单一服务器模式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">11.1.2.</span> <span class="toc-nav-text">SSO(single sign on)模式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">11.1.3.</span> <span class="toc-nav-text">Token 模式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">11.1.3.1.</span> <span class="toc-nav-text">使用 JWT 进行跨域身份验证</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">11.1.3.1.1.</span> <span class="toc-nav-text">传统用户身份验证</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">11.1.4.</span> <span class="toc-nav-text">项目会员登录、注册业务流程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">11.1.4.1.</span> <span class="toc-nav-text">登录</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">11.1.4.2.</span> <span class="toc-nav-text">注册</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">11.1.4.3.</span> <span class="toc-nav-text">微信登录</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">11.1.5.</span> <span class="toc-nav-text">项目管理员登录、注册业务流程</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">12.</span> <span class="toc-nav-text">微信支付</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.</span> <span class="toc-nav-text">面试题</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.1.</span> <span class="toc-nav-text">HTTP 协议是有状态还是无状态的</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.1.1.</span> <span class="toc-nav-text">定义</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.1.2.</span> <span class="toc-nav-text">举个例子</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.1.3.</span> <span class="toc-nav-text">具体场景</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.1.4.</span> <span class="toc-nav-text">总结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.2.</span> <span class="toc-nav-text">cookie、session、token</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.2.0.1.</span> <span class="toc-nav-text">Cookie</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.2.0.2.</span> <span class="toc-nav-text">Session</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.2.1.</span> <span class="toc-nav-text">cookie 与 session 的区别</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.2.2.</span> <span class="toc-nav-text">Token</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.2.3.</span> <span class="toc-nav-text">JWT 令牌</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.2.4.</span> <span class="toc-nav-text">OAuth2</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.2.5.</span> <span class="toc-nav-text">OAuth2 的四种方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.2.5.1.</span> <span class="toc-nav-text">授权码</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.3.</span> <span class="toc-nav-text">可能追问的问题</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">14.</span> <span class="toc-nav-text">Extention 阿里云 OSS</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">14.1.</span> <span class="toc-nav-text">准备环境</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">14.2.</span> <span class="toc-nav-text">开始操作</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">15.</span> <span class="toc-nav-text">Extention 阿里云 vod</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">16.</span> <span class="toc-nav-text">Extention 阿里云短信服务</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">
                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#project" title="project">project</a>
                        
                    </div>
                </section>
                
            </div>
        </div>
    </div>
</article>


<!-- disqus embedded js code start (one page only need to embed once) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "hujesse";
    var disqus_identifier = "https://hujesse83.github.io/2022/02/02/谷粒学院总结/";
    var disqus_url = "https://hujesse83.github.io/2022/02/02/谷粒学院总结/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus embedded js code start end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>

<script type="text/javascript" src="../source/js/zooming.js"></script>
<script id="dsq-count-scr" src="//hujesse.disqus.com/count.js" async></script>

    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/hujesse83">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; null 2022 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://beantech.org">BeanTech</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=YenYuHsuan&repo=hexo-theme-beantech&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://hujesse83.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://hujesse83.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
